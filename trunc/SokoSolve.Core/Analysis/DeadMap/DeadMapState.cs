using System;
using System.Collections.Generic;
using System.Text;
using SokoSolve.Common.Math;
using SokoSolve.Common.Structures;
using SokoSolve.Core.Analysis.Solver;
using SokoSolve.Core.Analysis.Solver.SolverStaticAnalysis;

namespace SokoSolve.Core.Analysis.DeadMap
{
    /// <summary>
    /// State Pattern for deadmap analysis
    /// </summary>
    public class DeadMapState : SolverBitmap
    {
        /// <summary>
        /// Strong Constructor. Start with the dead map including all walls.
        /// </summary>
        /// <param name="goalMap"></param>
        /// <param name="wallMap"></param>
        public DeadMapState(Bitmap goalMap, Bitmap wallMap, DeadMapAnalysis deadMapAnalysis)
            : base("Dead Map", wallMap.Size)
        {
            this.goalMap = goalMap;
            this.wallMap = wallMap;
            this.deadMapAnalysis = deadMapAnalysis;

            this.mapSize = wallMap.Size;

            if (goalMap == null) throw new ArgumentNullException("goalMap");
            if (wallMap == null) throw new ArgumentNullException("goalMap");
            if (deadMapAnalysis == null) throw new ArgumentNullException("deadMapAnalysis");
        }

        /// <summary>
        /// Strong Constructor. Start with the dead map including all walls.
        /// </summary>
        /// <param name="goalMap"></param>
        /// <param name="wallMap"></param>
        public DeadMapState(SolverNode currentNode, Bitmap goalMap, Bitmap wallMap, DeadMapAnalysis deadMapAnalysis)
            : this(goalMap, wallMap, deadMapAnalysis)
        {
            this.crateMap = currentNode.CrateMap;
            this.moveMap = currentNode.MoveMap;
            this.dynamicNode = currentNode;
        }


        public SolverNode DynamicNode
        {
            get { return dynamicNode; }
        }

        /// <summary>
        /// May be null for static
        /// </summary>
        public Bitmap CrateMap
        {
            get { return crateMap; }
        }

        /// <summary>
        /// May be null for static
        /// </summary>
        public Bitmap MoveMap
        {
            get { return moveMap; }
        }

        /// <summary>
        /// Static
        /// </summary>
        public Bitmap GoalMap
        {
            get { return goalMap; }
        }

        /// <summary>
        /// Static
        /// </summary>
        public Bitmap WallMap
        {
            get { return wallMap; }
        }

        /// <summary>
        /// Generated by the rule <see cref="CornerRule"/>, all corners in the puzzle
        /// </summary>
        public SolverBitmap CornerMap
        {
            get { return cornerMap; }
            set { cornerMap = value; }
        }

        /// <summary>
        /// Generated by the rule <see cref="RecessRule"/>
        /// </summary>
        public SolverBitmap RecessMap
        {
            get { return recessMap; }
            set { recessMap = value; }
        }

        /// <summary>
        /// Is the analysis dynamic
        /// </summary>
        public bool IsDynamic
        {
            get { return crateMap != null; }
        }



        /// <summary>
        /// Static Analysis
        /// </summary>
        public DeadMapAnalysis DeadMapAnalysis
        {
            get { return deadMapAnalysis; }
        }

        public StaticAnalysis StaticAnalysis
        {
            get { return deadMapAnalysis.StaticAnalysis; }
        }

        /// <summary>
        /// Cache. Helper to avoid costly size lookip
        /// </summary>
        public SizeInt MapSize
        {
            get { return mapSize; }
        }

        private Bitmap moveMap;
        private Bitmap crateMap;
        private Bitmap goalMap;
        private Bitmap wallMap;
        private SolverBitmap cornerMap;
        private SolverBitmap recessMap;
        private DeadMapAnalysis deadMapAnalysis;
        private SizeInt mapSize;
        private SolverNode dynamicNode;
    }
}
