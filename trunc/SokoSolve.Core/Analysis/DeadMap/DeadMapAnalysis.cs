using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using SokoSolve.Common.Math;
using SokoSolve.Common.Structures;
using SokoSolve.Common.Structures.Evaluation.Strategy;
using SokoSolve.Core.Analysis.Solver;

namespace SokoSolve.Core.Analysis.DeadMap
{
    /// <summary>
    /// Analyse a map to see if it is solveable or unsolvable/dead
    /// </summary>
    public class DeadMapAnalysis : StrategyPatternBase<DeadMapState>
    {
        /// <summary>
        /// Default Constructor. Register all strategy rules
        /// </summary>
        public DeadMapAnalysis() : base("DeadMap analysis")
        {
            Register(new CornerRule(this));
            Register(new BoxRule(this));
            Register(new RecessRule(this));
            Register(new HintsRule(this));
            Register(new CleanUpRule(this));
        }

        /// <summary>
        /// Build a deadmap
        /// </summary>
        /// <param name="crateMap"></param>
        /// <param name="goalMap"></param>
        /// <param name="wallMap"></param>
        /// <returns></returns>
        public DeadMapState BuildDeadMap(Bitmap crateMap, Bitmap goalMap, Bitmap wallMap, SolverStrategy strategy)
        {
            DeadMapState result = new DeadMapState(crateMap, goalMap, wallMap, strategy);
            Evaluate(result);
            return result;
        }
    }

    /// <summary>
    /// State Pattern for deadmap analysis
    /// </summary>
    public class DeadMapState : SolverBitmap
    {
        /// <summary>
        /// Strong Constructor. Start with the dead map including all walls.
        /// </summary>
        /// <param name="crateMap">map be null</param>
        /// <param name="goalMap"></param>
        /// <param name="wallMap"></param>
        public DeadMapState(Bitmap crateMap, Bitmap goalMap, Bitmap wallMap, SolverStrategy strategy) : base("Dead Map", wallMap.Size)
        {
            this.crateMap = crateMap;
            this.goalMap = goalMap;
            this.wallMap = wallMap;
            this.strategy = strategy;

            mapSize =wallMap.Size;

            if (goalMap == null) throw new ArgumentNullException("goalMap");
            if (wallMap == null) throw new ArgumentNullException("goalMap");
            if (strategy == null) throw new ArgumentNullException("strategy");
        }


        /// <summary>
        /// May be null
        /// </summary>
        public Bitmap CrateMap
        {
            get { return crateMap; }
        }

        /// <summary>
        /// Static
        /// </summary>
        public Bitmap GoalMap
        {
            get { return goalMap; }
        }

        /// <summary>
        /// Static
        /// </summary>
        public Bitmap WallMap
        {
            get { return wallMap; }
        }

        /// <summary>
        /// Generated by the rule <see cref="CornerRule"/>, all corners in the puzzle
        /// </summary>
        public SolverBitmap CornerMap
        {
            get { return cornerMap; }
            set { cornerMap = value; }
        }

        /// <summary>
        /// Generated by the rule <see cref="RecessRule"/>
        /// </summary>
        public SolverBitmap RecessMap
        {
            get { return recessMap; }
            set { recessMap = value; }
        }

        /// <summary>
        /// Is the analysis dynamic
        /// </summary>
        public bool IsDynamic
        {
            get { return crateMap != null; }
        }

        /// <summary>
        /// Static Analysis
        /// </summary>
        public SolverStrategy Strategy
        {
            get { return strategy; }
            set { strategy = value; }
        }

        public StaticAnalysis Analysis
        {
            get { return strategy.StaticAnalysis;  }
        }

        /// <summary>
        /// Cache. Helper to avoid costly size lookip
        /// </summary>
        public SizeInt MapSize
        {
            get { return mapSize; }
        }

        private Bitmap crateMap;
        private Bitmap goalMap;
        private Bitmap wallMap;
        private SolverBitmap cornerMap;
        private SolverBitmap recessMap;
        private SolverStrategy strategy;
        private SizeInt mapSize;
    }
  
    
}
