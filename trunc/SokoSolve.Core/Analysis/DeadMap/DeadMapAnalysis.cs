using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using SokoSolve.Common.Math;
using SokoSolve.Common.Structures;
using SokoSolve.Common.Structures.Evaluation.Strategy;
using SokoSolve.Core.Analysis.Solver;

namespace SokoSolve.Core.Analysis.DeadMap
{
    class DeadMapAnalysis : StrategyPatternBase<DeadMapState>
    {
        public DeadMapAnalysis() : base("DeadMap analysis")
        {
            Register(new CornerRule(this));
            Register(new BoxRule(this));
            Register(new RecessRule(this));
        }

        /// <summary>
        /// Build a deadmap
        /// </summary>
        /// <param name="crateMap"></param>
        /// <param name="goalMap"></param>
        /// <param name="wallMap"></param>
        /// <returns></returns>
        public DeadMapState BuildDeadMap(Bitmap crateMap, Bitmap goalMap, Bitmap wallMap)
        {
            DeadMapState result = new DeadMapState(crateMap, goalMap, wallMap);
            Evaluate(result);
            return result;
        }
    }

    /// <summary>
    /// State for deadmap analysis
    /// </summary>
    public class DeadMapState : SolverBitmap
    {
        /// <summary>
        /// Strong Constructor. Start with the dead map including all walls.
        /// </summary>
        /// <param name="crateMap">map be null</param>
        /// <param name="goalMap"></param>
        /// <param name="wallMap"></param>
        public DeadMapState(Bitmap crateMap, Bitmap goalMap, Bitmap wallMap) : base("Dead Map", wallMap.Size)
        {
            this.crateMap = crateMap;
            this.goalMap = goalMap;
            this.wallMap = wallMap;

            if (goalMap == null) throw new ArgumentNullException("goalMap");
            if (wallMap == null) throw new ArgumentNullException("goalMap");
        }


        /// <summary>
        /// May be null
        /// </summary>
        public Bitmap CrateMap
        {
            get { return crateMap; }
        }

        public Bitmap GoalMap
        {
            get { return goalMap; }
        }

        public Bitmap WallMap
        {
            get { return wallMap; }
        }

        /// <summary>
        /// Generated by the rule <see cref="CornerRule"/>, all corners in the puzzle
        /// </summary>
        public SolverBitmap CornerMap
        {
            get { return cornerMap; }
            set { cornerMap = value; }
        }

        /// <summary>
        /// Generated by the rule <see cref="RecessRule"/>
        /// </summary>
        public SolverBitmap RecessMap
        {
            get { return recessMap; }
            set { recessMap = value; }
        }

        /// <summary>
        /// Is the analysis dynamic
        /// </summary>
        public bool IsDynamic
        {
            get { return crateMap != null; }
        }

        private Bitmap crateMap;
        private Bitmap goalMap;
        private Bitmap wallMap;
        private SolverBitmap cornerMap;
        private SolverBitmap recessMap;
    }
  
    
}
